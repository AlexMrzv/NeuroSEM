# -*- coding: utf-8 -*-
import shutil

# Form implementation generated from reading ui file 'tubes_detection2.ui'
#
# Created by: PyQt5 UI code generator 5.15.9
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.


from PyQt5 import QtCore, QtGui, QtWidgets
import os
import cv2
import pytesseract
from tkinter.messagebox import showerror, showinfo
from tkinter import filedialog
import winapps
import tensorflow as tf
import numpy as np
import pandas as pd
import traceback


class Ui_MainWindow(object):
    def setupUi(self, MainWindow):
        MainWindow.setObjectName("MainWindow")
        MainWindow.resize(1263, 830)
        MainWindow.setMinimumSize(QtCore.QSize(395, 252))
        MainWindow.setMaximumSize(QtCore.QSize(10000, 10000))
        font = QtGui.QFont()
        font.setFamily("GOST type A")
        font.setPointSize(18)
        font.setBold(False)
        font.setItalic(False)
        font.setUnderline(False)
        font.setWeight(50)
        font.setStrikeOut(False)
        font.setKerning(True)
        MainWindow.setFont(font)
        MainWindow.setCursor(QtGui.QCursor(QtCore.Qt.ArrowCursor))
        MainWindow.setMouseTracking(False)
        MainWindow.setFocusPolicy(QtCore.Qt.NoFocus)
        MainWindow.setAutoFillBackground(False)
        MainWindow.setStyleSheet("background-color:#323437")
        self.centralwidget = QtWidgets.QWidget(MainWindow)
        self.centralwidget.setObjectName("centralwidget")
        self.uploadImage = QtWidgets.QPushButton(self.centralwidget)
        self.uploadImage.setGeometry(QtCore.QRect(1070, 700, 161, 71))
        font = QtGui.QFont()
        font.setFamily("inherit")
        font.setPointSize(-1)
        font.setBold(False)
        font.setItalic(False)
        font.setWeight(50)
        self.uploadImage.setFont(font)
        self.uploadImage.setStyleSheet("QPushButton#uploadImage {\n"
                                       "    background-color:#e2b714;\n"
                                       "    border-radius: 10px;\n"
                                       "    font:  18px;\n"
                                       "    padding: 5px;\n"
                                       "    font-family: inherit;\n"
                                       "    \n"
                                       " \n"
                                       "}\n"
                                       "QPushButton#uploadImage:hover {\n"
                                       "  background-color:#d1d0c5;\n"
                                       "}\n"
                                       "\n"
                                       "QPushButton#uploadImage:pressed {\n"
                                       "background-color:#646669;\n"
                                       "border: 1px solid #d1d0c5;\n"
                                       "}")
        self.uploadImage.setObjectName("uploadImage")
        self.downloaExcel = QtWidgets.QPushButton(self.centralwidget)
        self.downloaExcel.setGeometry(QtCore.QRect(1070, 600, 161, 71))
        font = QtGui.QFont()
        font.setFamily("inherit")
        font.setPointSize(-1)
        font.setBold(False)
        font.setItalic(False)
        font.setWeight(50)
        self.downloaExcel.setFont(font)
        self.downloaExcel.setCursor(QtGui.QCursor(QtCore.Qt.ArrowCursor))
        self.downloaExcel.setFocusPolicy(QtCore.Qt.NoFocus)
        self.downloaExcel.setStyleSheet("QPushButton#downloaExcel {\n"
                                        "    font: 75 8pt \"MS Shell Dlg 2\";\n"
                                        "    background-color:#e2b714;\n"
                                        "    border-radius: 10px;\n"
                                        "    font:  18px;\n"
                                        "    padding: 5px;\n"
                                        "    font-family: inherit;\n"
                                        "    \n"
                                        " \n"
                                        "}\n"
                                        "QPushButton#downloaExcel:hover {\n"
                                        "  background-color:#d1d0c5;\n"
                                        "}\n"
                                        "\n"
                                        "QPushButton#downloaExcel:pressed {\n"
                                        "background-color:#646669;\n"
                                        "border: 1px solid #d1d0c5;\n"
                                        "}")
        self.downloaExcel.setObjectName("downloaExcel")
        self.stackedWidget = QtWidgets.QStackedWidget(self.centralwidget)
        self.stackedWidget.setGeometry(QtCore.QRect(30, 10, 1024, 798))
        self.stackedWidget.setMinimumSize(QtCore.QSize(256, 0))
        self.stackedWidget.setStyleSheet("QstackedWidget#stackedWidget {\n"
                                         "display: box;\n"
                                         "background-color: red;\n"
                                         "border: 2px solid green;\n"
                                         "}")
        self.stackedWidget.setFrameShape(QtWidgets.QFrame.Box)
        self.stackedWidget.setObjectName("stackedWidget")
        MainWindow.setCentralWidget(self.centralwidget)
        self.menubar = QtWidgets.QMenuBar(MainWindow)
        self.menubar.setGeometry(QtCore.QRect(0, 0, 1263, 26))
        self.menubar.setObjectName("menubar")
        MainWindow.setMenuBar(self.menubar)
        self.statusbar = QtWidgets.QStatusBar(MainWindow)
        self.statusbar.setSizeGripEnabled(True)
        self.statusbar.setObjectName("statusbar")
        MainWindow.setStatusBar(self.statusbar)
        self.retranslateUi(MainWindow)
        self.stackedWidget.setCurrentIndex(1)
        QtCore.QMetaObject.connectSlotsByName(MainWindow)
        self.values = pd.DataFrame
        self.outside = pd.DataFrame
        self.inside = pd.DataFrame
        self.scalewidth = pd.DataFrame
        self.imgs = {}
        self.label = {}
        self.downloaExcel.hide()

    def retranslateUi(self, MainWindow):
        _translate = QtCore.QCoreApplication.translate
        MainWindow.setWindowTitle(_translate("MainWindow", "tubes detection"))
        self.uploadImage.setText(_translate("MainWindow", "upload image"))
        self.downloaExcel.setText(_translate("MainWindow", "download excel"))
        self.uploadImageButtonClick()
        self.downloadExcel()

    def uploadImageButtonClick(self):
        self.uploadImage.clicked.connect(self.get_image)

    def downloadExcel(self):
        self.downloaExcel.clicked.connect(self.download)

    def download(self):
        res = filedialog.asksaveasfilename(defaultextension='.xlsx', filetypes=[('Escel','.xlsx')], initialfile='result')
        with pd.ExcelWriter(res) as writer:
            for i in os.listdir('outside/outside/labels'):
                output = self.values.loc[(self.values['filename'] == i)]
                output.to_excel(writer, sheet_name=i.split('.')[0], index=False)

    def add_pages(self):
        for ind, i in enumerate(os.listdir('img')):
            self.new_page = QtWidgets.QWidget()
            self.new_page.setObjectName(i)
            self.label[i] = QtWidgets.QLabel(self.new_page)
            self.label[i].setGeometry(QtCore.QRect(0, 0, 1024, 768))
            self.show_button = QtWidgets.QPushButton(self.new_page)
            self.show_button.setText('Show')
            self.show_button.setGeometry(452, 768, 60, 30)
            self.hide_button = QtWidgets.QPushButton(self.new_page)
            self.hide_button.setText('Hide')
            self.hide_button.setGeometry(512, 768, 60, 30)
            self.next_button = QtWidgets.QPushButton(self.new_page)
            self.next_button.setText('Next')
            self.next_button.setGeometry(964, 768, 60, 30)
            self.previos_button = QtWidgets.QPushButton(self.new_page)
            self.previos_button.setText('Previous')
            self.previos_button.setGeometry(0, 768, 60, 30)
            self.stackedWidget.addWidget(self.new_page)
            self.label[i].setPixmap(QtGui.QPixmap(f"img/{i}"))
            self.label[i].setScaledContents(True)
            self.next_button.setStyleSheet('color: white; \n'
                                           'border-style: none;')
            self.previos_button.setStyleSheet('color: white; \n'
                                           'border-style: none;')
            self.show_button.setStyleSheet('color: white; \n'
                                           'border-style: none;')
            self.hide_button.setStyleSheet('color: white; \n'
                                           'border-style: none;')
            self.next_button.clicked.connect(self.next_page)
            self.previos_button.clicked.connect(self.previous_page)
            self.show_button.clicked.connect(self.show_image)
            self.hide_button.clicked.connect(self.hide_image)
            self.imgs[ind] = i

    def show_image(self):
        self.label[self.imgs[self.stackedWidget.currentIndex()]].setPixmap(
            QtGui.QPixmap(f"result/{self.imgs[self.stackedWidget.currentIndex()]}"))

    def hide_image(self):
        self.label[self.imgs[self.stackedWidget.currentIndex()]].setPixmap(
            QtGui.QPixmap(f"img/{self.imgs[self.stackedWidget.currentIndex()]}"))

    def next_page(self):
        self.stackedWidget.setCurrentIndex(self.stackedWidget.currentIndex() + 1)

    def previous_page(self):
        self.stackedWidget.setCurrentIndex(self.stackedWidget.currentIndex() - 1)

    def check_laters(self, filepath):
        laters = set('абвгдеёжзийклмнопрстуфхцчшщъыьэюя')
        return laters.intersection(filepath.lower()) != set()

    def predobrabotka(self, input_image):
        image = cv2.imread(input_image, cv2.IMREAD_GRAYSCALE)
        image = np.asarray(image)
        image = np.expand_dims(image, axis=0)
        image = tf.image.adjust_contrast(image, 2.)
        filename = input_image.split('/')[-1]
        cv2.imwrite(f'img/{filename}', (image.numpy()[0]))

    def getnums(self, input_value):
        result = ''
        for i in input_value:
            if i.isdigit():
                result += i
        return result

    def relative_to_absolute(self, width, height, xList, yList, widthList, filename, heightList):
        output = pd.DataFrame(
            {
                'filename': [filename for i in range(len(xList))],
                'x': xList,
                'y': yList,
                'width': widthList,
                'height': heightList
            }
        )
        output['x'] = round(output['x'] * width)
        output['y'] = round(output['y'] * height)
        output['width'] = round(output['width'] * width)
        output['height'] = round(output['height'] * height)
        return output

    def scale_len(self):
        result = []
        filenames = []
        for filename in os.listdir('scale/scale/crops/polosochka'):
            image = cv2.imread(f'scale/scale/crops/polosochka/{filename}')
            width = []
            for ind, i in enumerate(image[round(len(image) / 2)]):
                if i[0] == 0:
                    width.append(ind)
            if len(width) >= 3 and (max(width) - min(width)) > len(width) / 2:
                result.append(max(width) - min(width))
            else:
                result.append(len(image[0]))
            filenames.append(filename)
        return pd.DataFrame({
            'filename': filenames,
            'scale_width': result
        })

    def accordance(self, outside, inside):
        result = pd.DataFrame({
            'filename': [],
            'x_outside': [],
            'y_outside': [],
            'width_outside': [],
            'height_outside': [],
            'x_inside': [],
            'y_inside': [],
            'width_inside': [],
            'height_inside': []
        })
        for i in range(len(outside)):
            x = int(outside['x'][i])
            y = int(outside['y'][i])
            width = int(outside['width'][i])
            height = int(outside['height'][i])
            filename = str(outside['filename'][i])
            sort = pd.DataFrame()
            if x - width/2 > 0 and y-height/2 > 0 and x + width/2 < 1023 and y + height/2 < 768:
                sort = inside.loc[(
                        (abs(inside['x'] - x) < round(width / 2)) & (abs(inside['y'] - y) < round(width / 2)) & (
                        inside['width'] - width < 0) & (
                                inside['filename'] == filename))]
            if not sort.empty:
                fx = sort.iloc[0]['x']
                fy = sort.iloc[0]['y']
                fwidth = sort.iloc[0]['width']
                fheight = sort.iloc[0]['height']
                result.loc[len(result.index)] = [filename, x, y, width, height, fx, fy, fwidth, fheight]
        return result

    def diameter_and_wall_thickness(self, scale_width, values, words_in_picture):
        output = pd.DataFrame({
            'filename': [],
            'x_outside': [],
            'y_outside': [],
            'width_outside': [],
            'height_outside': [],
            'x_inside': [],
            'y_inside': [],
            'width_inside': [],
            'height_inside': [],
            'diameter': [],
            'wall_thickness': []
        })
        for i in range(len(scale_width)):
            scale_len = int(scale_width.iloc[i]['scale_width'])
            filename = scale_width.iloc[i]['filename'].split('.')[0] + '.txt'
            sort = values.loc[(values['filename'] == filename)]
            for ind, word in words_in_picture.items():
                if filename.split('.')[0] in ind:
                    scale_num = word
                    break
            sort['diameter'] = sort['width_outside'] / scale_len * scale_num
            sort['wall_thickness'] = (sort['width_outside'] - sort['width_inside']) / scale_len * scale_num / 2
            output = pd.concat([output, sort], ignore_index=True)
        return output

    def prediction(self):
        os.system(
            'python yolov5/detect.py '
            '--weights scale.pt '
            '--img 1024 '
            '--conf 0.8 '
            '--source img '
            '--save-crop '
            '--nosave '
            '--name scale '
            '--project ./scale'
        )
        os.system(
            'python yolov5/detect.py '
            '--weights inside.pt '
            '--img 1024 '
            '--conf 0.4 '
            '--source img '
            '--save-txt '
            '--nosave '
            '--name inside '
            '--project ./inside'
        )
        os.system(
            'python yolov5/detect.py '
            '--weights outside.pt '
            '--img 1024 '
            '--conf 0.4 '
            '--source img '
            '--save-txt '
            '--nosave '
            '--name outside '
            '--project ./outside'
        )
        resultDict = {}
        for filename in os.listdir('scale/scale/crops/polosochka'):
            scaleimage = cv2.imread(f'scale/scale/crops/polosochka/{filename}', cv2.IMREAD_GRAYSCALE)
            thresh = 200
            bwimage = cv2.threshold(scaleimage, thresh, 255, cv2.THRESH_BINARY)[1]
            cv2.imwrite(f'scale/scale/crops/polosochka/{filename}', bwimage)
            pytesseract.pytesseract.tesseract_cmd = 'C:\\Program Files\\Tesseract-OCR\\tesseract.exe'
            resultDict[filename] = pytesseract.image_to_string(bwimage)
        return resultDict

    def save_results(self):
        shutil.rmtree('result', True)
        os.mkdir('result')
        for filename in os.listdir('img'):
            image = cv2.imread(f'img/{filename}')
            data = self.values.loc[(filename.split('.')[0] + '.txt' == self.values['filename'])]
            for i in range(len(data)):
                p1x = int(data.iloc[i]['x_outside'] - round(data.iloc[i]['width_outside'] / 2))
                p1y = int(data.iloc[i]['y_outside'] - round(data.iloc[i]['height_outside'] / 2))
                p2x = int(data.iloc[i]['x_outside'] + round(data.iloc[i]['width_outside'] / 2))
                p2y = int(data.iloc[i]['y_outside'] + round(data.iloc[i]['height_outside'] / 2))
                cv2.rectangle(image, (p1x, p1y), (p2x, p2y), (0, 255, 0), 2)
                p1x = int(data.iloc[i]['x_inside'] - round(data.iloc[i]['width_inside'] / 2))
                p1y = int(data.iloc[i]['y_inside'] - round(data.iloc[i]['height_inside'] / 2))
                p2x = int(data.iloc[i]['x_inside'] + round(data.iloc[i]['width_inside'] / 2))
                p2y = int(data.iloc[i]['y_inside'] + round(data.iloc[i]['height_inside'] / 2))
                cv2.rectangle(image, (p1x, p1y), (p2x, p2y), (0, 255, 0), 2)
            cv2.imwrite(f'result/{filename}', image)

    def get_image(self):
        self.values = pd.DataFrame
        self.outside = pd.DataFrame
        self.inside = pd.DataFrame
        self.scalewidth = pd.DataFrame
        shutil.rmtree('img', True)
        shutil.rmtree('inside', True)
        shutil.rmtree('outside', True)
        shutil.rmtree('scale', True)
        input_images = filedialog.askopenfilenames(initialdir="main",
                                                   title="Select an Images",
                                                   filetypes=[
                                                       ('Image file', '.png .jpg .jpeg'),
                                                       ('All files', '*')])
        if not input_images:
            return None
        if 'img' not in os.listdir():
            os.mkdir('img')
        for i in input_images:
            if self.check_laters(i):
                showerror('Error', 'There are invalid letters in the file path')
                self.get_image()
                return None
        for i in input_images:
            self.predobrabotka(i)
        words_in_picture = self.prediction()
        for ind, i in words_in_picture.items():
            words_in_picture[ind] = int(self.getnums(i))
        for filename in os.listdir('inside/inside/labels'):
            nothing = os.listdir('img')
            for i in nothing:
                if filename.split(".")[0] in i:
                    width = i
                    break
            height = len(cv2.imread(f'img/{width}'))
            width = len(cv2.imread(f'img/{width}')[0])
            inside_file = open(f'inside/inside/labels/{filename}', 'r')
            raw_text = inside_file.read().split('\n')
            xList = []
            yList = []
            widthList = []
            heightList = []
            for i in raw_text:
                bList = i.split(' ')
                if bList != ['']:
                    xList.append(float(bList[1]))
                    yList.append(float(bList[2]))
                    widthList.append(float(bList[3]))
                    heightList.append(float(bList[4]))
            if self.inside.empty:
                self.inside = self.relative_to_absolute(width, height, xList, yList, widthList, filename, heightList)
            else:
                self.inside = pd.concat([self.inside,
                                         self.relative_to_absolute(width, height, xList, yList, widthList, filename,
                                                                   heightList)],
                                        ignore_index=True)
            outside_file = open(f'outside/outside/labels/{filename}', 'r')
            raw_text = outside_file.read().split('\n')
            xList = []
            yList = []
            widthList = []
            heightList = []
            for i in raw_text:
                bList = i.split(' ')
                if bList != ['']:
                    xList.append(float(bList[1]))
                    yList.append(float(bList[2]))
                    widthList.append(float(bList[3]))
                    heightList.append(float(bList[4]))
            if self.outside.empty:
                self.outside = self.relative_to_absolute(width, height, xList, yList, widthList, filename, heightList)
            else:
                self.outside = pd.concat(
                    [self.outside,
                     self.relative_to_absolute(width, height, xList, yList, widthList, filename, heightList)],
                    ignore_index=True)
        self.scalewidth = self.scale_len()
        self.values = self.accordance(self.outside, self.inside)
        self.values = self.diameter_and_wall_thickness(self.scalewidth, self.values, words_in_picture)
        self.add_pages()
        self.save_results()
        self.downloaExcel.show()

if __name__ == "__main__":
    import sys

    teserct_is_installed = winapps.search_installed('Tesseract-OCR')
    while not teserct_is_installed:
        showerror('Error', 'Tesseract-OCR is not installed. Please visit https://github.com/UB-Mannheim/tesseract/wiki')
    if 'yolov5' not in os.listdir():
        os.system('git clone https://github.com/ultralytics/yolov5')
    os.system('pip install openpyxl')
    os.system('pip install -qr yolov5/requirements.txt')
    app = QtWidgets.QApplication(sys.argv)
    MainWindow = QtWidgets.QMainWindow()
    ui = Ui_MainWindow()
    ui.setupUi(MainWindow)
    MainWindow.show()
    sys.exit(app.exec_())